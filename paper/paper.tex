\documentclass{sig-alternate}
\usepackage{biblatex}

\newcommand{\code}[1]{\texttt{#1}}

\author{
\alignauthor{}
Dan Stelljes\\
  \affaddr{Division of Science and Mathematics}\\
  \affaddr{University of Minnesota, Morris}\\
  \affaddr{Morris, Minnesota, USA 56267}\\
  \email{stell124@morris.umn.edu}
}
\conferenceinfo{UMM CSci Senior Seminar Conference, December 2016}{Morris, MN}
\title{Composable Concurrency Models}

\bibliography{references}

% space is limited:
\AtEveryBibitem{\clearfield{doi}}
\AtEveryBibitem{\clearfield{isbn}}
\AtEveryBibitem{\clearfield{note}}
\AtEveryBibitem{\clearfield{url}}

\begin{document}

\maketitle

\begin{abstract}

The need to manage concurrent operations in applications has led to the development of a wide variety of concurrency models. Modern programming languages each provide several concurrency models to serve different requirements, and programmers benefit from being able to use them in tandem. We discuss challenges surrounding concurrency control and examine situations in which conflicts between models can occur.

\end{abstract}

\section*{Key points}

The goal of this research is to discover and explain common properties of concurrency models (the actor model, software transactional memory, etc.) and demonstrate possible conflicts between them, ultimately showing how they can work together. The research is scoped to concurrency management---while some of the findings may apply to parallel programming, the source material primarily deals with language-level constructs.

Swalens et al.~\cite{Swalens2014} specifically examine the composability of various concurrency models in Clojure. They provide a significant amount of accessible background material, but stop short of actually defining any composable language-level abstractions; the paper serves largely as a foundation for future work. Marr (an author on that paper) and D'Hondt~\cite{Marr2012} discuss unifying concurrency abstractions with the goal of increasing virtual machine-level support for various high-level concurrency models. They propose an ownership-based meta-object protocol as a solution, and demonstrate the implementation of some common concurrency models. Ziv et al.~\cite{Ziv2015} provide formal definitions of requirements for concurrency control (deadlock safety, serializability, etc.) in order to prove composability. The paper was written with databases in mind and is (perhaps obviously) quite heavy on theory, but it provides precise definitions for several important concepts.

All of the mentioned sources deal specifically with composability, though approaches are different. Swalens et al.~\cite{Swalens2014} work at the language level with a focus on the programmer; Marr and D'Hondt~\cite{Marr2012} work at the virtual machine level with a focus on performant abstractions that can accommodate models from various higher-level languages. Taken together, those papers provide a decent foundation for examining different concurrency models. Ziv et al.~\cite{Ziv2015} attack the problem from a purely theoretical perspective which, although helpful, doesn't relate particularly well to the more practical approaches.

Swalens et al.~\cite{Swalens2014} demonstrate issues in the context of Clojure's concurrency models, providing code where appropriate. Those and similar examples could be quite useful in illustrating composability challenges. Marr and D'Hondt~\cite{Marr2012} implement Clojure's agents in Smalltalk and compare that implementation and an implementation of a software transactional memory system (LRSTM) to the proposed meta-object protocol. The comparison's benchmark results demonstrate that VM support is necessary to reduce performance of the MOP to an acceptable level, but are not especially relevant outside of that context. As far as the general state of the research, it seems that a variety of unifying mechanisms have been proposed but languages generally just work around possible issues (for instance, Clojure doesn't send a message to an agent inside a \code{dosync} block until the transaction is committed).

It seems reasonable to assume that the audience already has an intuitive understanding of different types of concurrent operations (disk reads, file downloads, etc.). However, concepts like atomicity and deadlock avoidance may have to be explained.

\section{Introduction}

\section{Background}

\section{Common concurrency models}

\subsection{Atomics}

\subsection{Communicating threads}

\subsection{Coroutines}

\subsection{Futures}

\subsection{Software transactional memory}

\section{Composability challenges}

\section{Proposed solutions}

\section{Conclusions}

\section{Acknowledgments}

\section{References}

\printbibliography[heading=none]

\end{document}
